
import { storage } from "./storage";
import type { Task } from "../shared/schema";
import { Resend } from 'resend';

interface TaskReminder {
  taskId: string;
  reminderTime: Date;
  reminderType: string;
  sent: boolean;
}

class TaskNotificationScheduler {
  private reminders: Map<string, TaskReminder[]> = new Map();
  private interval: NodeJS.Timeout | null = null;

  private createResendClient() {
    const resendApiKey = process.env.RESEND_API_KEY;
    
    if (!resendApiKey) {
      console.log('[TaskScheduler] No RESEND_API_KEY configured');
      return null;
    }
    
    return new Resend(resendApiKey);
  }

  private async sendTaskReminderEmail(task: Task, reminderType: string) {
    try {
      console.log(`[TaskScheduler] Attempting to send email reminder for task: ${task.title}`);
      
      const resend = this.createResendClient();
      
      if (!resend) {
        console.log('[TaskScheduler] No Resend API key configured. Logging notification instead.');
        console.log(`=== TASK REMINDER EMAIL (NOT SENT) ===`);
        console.log(`Task: ${task.title}`);
        console.log(`Due in: ${reminderType}`);
        console.log(`Description: ${task.description || 'No description'}`);
        console.log('====================================');
        return false;
      }

      let sourceType = "Manual";
      if (task.metadata?.aiGenerated) {
        sourceType = "AI Converted";
      } else if (task.sourceApp === "gmail") {
        sourceType = "Mail Converted";
      }

      const subject = `‚è∞ Task Reminder: Due in ${reminderType}`;
      const htmlContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Task Reminder</h2>
          <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0; color: #2563eb;">${task.title}</h3>
            <p><strong>Due in:</strong> ${reminderType}</p>
            <p><strong>Priority:</strong> ${task.priority || 'normal'}</p>
            <p><strong>Source:</strong> ${sourceType}</p>
            ${task.description ? `<p><strong>Description:</strong> ${task.description}</p>` : ''}
            ${task.dueAt ? `<p><strong>Due Date:</strong> ${new Date(task.dueAt).toLocaleString()}</p>` : ''}
          </div>
          <p style="color: #666; font-size: 14px;">
            This reminder was automatically generated by FlowHub Command Center.
          </p>
        </div>
      `;
      
      const textContent = `Task Reminder: ${task.title}\n\nDue in: ${reminderType}\nPriority: ${task.priority || 'normal'}\nSource: ${sourceType}\n${task.description ? `Description: ${task.description}` : ''}\n${task.dueAt ? `Due Date: ${new Date(task.dueAt).toLocaleString()}` : ''}\n\nThis reminder was automatically generated by FlowHub Command Center.`;

      console.log(`[TaskScheduler] Sending task reminder email via Resend: ${subject}`);

      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || 'chavanuday407@gmail.com',
        to: process.env.NOTIFICATION_EMAIL || 'chavanuday407@gmail.com',
        subject: subject,
        html: htmlContent,
        text: textContent
      });
      
      console.log(`[TaskScheduler] Task reminder email sent successfully via Resend: ${subject}`, result.data?.id);
      return true;
    } catch (error) {
      console.error(`[TaskScheduler] Resend email sending failed for task reminder: ${task.title}`);
      console.error('[TaskScheduler] Error details:', error);

      // Log the notification content even if email fails
      console.log('=== TASK REMINDER EMAIL (FAILED TO SEND) ===');
      console.log(`Task: ${task.title}`);
      console.log(`Due in: ${reminderType}`);
      console.log(`Description: ${task.description || 'No description'}`);
      console.log('==========================================');

      return false;
    }
  }

  start() {
    // Check for reminders every minute
    this.interval = setInterval(() => {
      this.checkAndSendReminders();
    }, 60000);
    
    // Backfill reminders for existing tasks on startup
    this.backfillExistingTaskReminders();
  }

  stop() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }

  async scheduleTaskReminders(task: Task) {
    if (!task.dueAt || task.status === 'completed') return;

    const dueDate = new Date(task.dueAt);
    const now = new Date();
    const reminders: TaskReminder[] = [];

    // Schedule reminders: 1 hour, 30 min, 15 min, 10 min, 5 min before due
    const reminderTimes = [
      { minutes: 60, label: "1 hour" },
      { minutes: 30, label: "30 minutes" },
      { minutes: 15, label: "15 minutes" },
      { minutes: 10, label: "10 minutes" },
      { minutes: 5, label: "5 minutes" }
    ];

    for (const reminder of reminderTimes) {
      const reminderTime = new Date(dueDate.getTime() - reminder.minutes * 60 * 1000);
      
      // If reminder time is in the past, send immediately
      if (reminderTime <= now) {
        console.log(`[TaskScheduler] Task "${task.title}" is within ${reminder.label} of deadline - sending immediate reminder`);
        await this.sendTaskReminder(task.id, reminder.label);
      } else {
        // Schedule for future
        reminders.push({
          taskId: task.id,
          reminderTime,
          reminderType: reminder.label,
          sent: false
        });
      }
    }

    if (reminders.length > 0) {
      this.reminders.set(task.id, reminders);
    }
  }

  private async checkAndSendReminders() {
    const now = new Date();

    // Check for priority promotions (Important -> Urgent when < 2 hours)
    await this.checkTaskPriorityPromotions();

    for (const [taskId, taskReminders] of this.reminders.entries()) {
      for (const reminder of taskReminders) {
        if (!reminder.sent && reminder.reminderTime <= now) {
          await this.sendTaskReminder(taskId, reminder.reminderType);
          reminder.sent = true;
        }
      }

      // Clean up sent reminders
      const activeReminders = taskReminders.filter(r => !r.sent);
      if (activeReminders.length === 0) {
        this.reminders.delete(taskId);
      } else {
        this.reminders.set(taskId, activeReminders);
      }
    }
  }

  private async checkTaskPriorityPromotions() {
    try {
      console.log('[TaskScheduler] Checking for priority promotions...');
      
      // Get urgent and important tasks across all users that are not completed
      const urgentTasks = await storage.getTasksByPriority("urgent");
      const importantTasks = await storage.getTasksByPriority("important");
      console.log(`[TaskScheduler] Found ${urgentTasks.length} urgent tasks, ${importantTasks.length} important tasks`);
      
      const activeTasks = importantTasks.filter(task => 
        task.status !== "completed" && 
        task.dueAt
      );
      console.log(`[TaskScheduler] Found ${activeTasks.length} active tasks with due dates`);

      const now = new Date();
      for (const task of activeTasks) {
        const dueDate = new Date(task.dueAt!);
        const timeRemaining = dueDate.getTime() - now.getTime();
        const hoursRemaining = timeRemaining / (1000 * 60 * 60);

        // Promote to urgent if less than 2 hours remaining
        if (hoursRemaining < 2 && hoursRemaining > 0) {
          await storage.updateTask(task.id, { priority: "urgent" });
          console.log(`[TaskScheduler] Promoted task "${task.title}" from Important to Urgent (${Math.round(hoursRemaining * 60)} minutes remaining)`);
        }
      }
    } catch (error) {
      console.error("Error checking task priority promotions:", error);
    }
  }

  private async sendTaskReminder(taskId: string, reminderType: string) {
    try {
      const task = await storage.getTaskById(taskId);
      if (!task || task.status === 'completed') return;

      let sourceType = "Manual";
      if (task.metadata?.aiGenerated) {
        sourceType = "AI Converted";
      } else if (task.sourceApp === "gmail") {
        sourceType = "Mail Converted";
      }

      // Store notification data for browser notification API
      await storage.createNotification({
        userId: task.userId,
        title: `Task Due in ${reminderType}`,
        description: `${sourceType} task "${task.title}" is due in ${reminderType}. ${task.description || ''}`,
        type: "browser_notification",
        sourceApp: "system",
        aiSummary: `Reminder for ${sourceType.toLowerCase()} task due in ${reminderType}`,
        actionableInsights: ["Complete task", "Reschedule task", "Mark as done"],
        metadata: {
          taskId: task.id,
          reminderType,
          sourceType,
          browserNotification: true
        }
      });

      console.log(`[TaskScheduler] Created browser notification for task "${task.title}" due in ${reminderType}`);

      // SEND EMAIL REMINDER - This was missing!
      await this.sendTaskReminderEmail(task, reminderType);

    } catch (error) {
      console.error(`Failed to send reminder for task ${taskId}:`, error);
    }
  }

  removeTaskReminders(taskId: string) {
    this.reminders.delete(taskId);
  }

  private async backfillExistingTaskReminders() {
    try {
      console.log('[TaskScheduler] Backfilling reminders for existing tasks...');
      
      // Get all tasks with future due dates
      const allTasks = await storage.getTasksByPriority("urgent");
      const importantTasks = await storage.getTasksByPriority("important");
      const normalTasks = await storage.getTasksByPriority("normal");
      
      const tasksWithDueDates = [...allTasks, ...importantTasks, ...normalTasks]
        .filter(task => task.dueAt && task.status !== 'completed' && new Date(task.dueAt) > new Date());
      
      for (const task of tasksWithDueDates) {
        await this.scheduleTaskReminders(task);
      }
      
      console.log(`[TaskScheduler] Backfilled reminders for ${tasksWithDueDates.length} tasks`);
    } catch (error) {
      console.error('Error backfilling task reminders:', error);
    }
  }
}

export const taskNotificationScheduler = new TaskNotificationScheduler();
